"""
Image service module for handling image operations.

This module handles image CRUD operations and related business logic.
"""

# Generated by Copilot
import os
import base64
from typing import List, Tuple
from sqlalchemy.orm import Session
from sqlalchemy import func
from API.db.models import Image, Mask
from shared.types.image import ApiImage, UploadImageRequest, process_type


def get_next_image_id(session: Session) -> int:
    """Get the next image ID based on the last image in the database."""
    count_images = session.query(Image).count()
    return count_images + 1 if count_images > 0 else 1


def get_images_by_done_status(
    session: Session, done: int, which: process_type, offset: int = 0, limit: int = 10
) -> Tuple[List[Image], int]:
    """
    Get images based on their done status (whether all masks are marked as done).

    Args:
        session: Database session
        done: 1 if getting images with all masks done, 0 if getting images with incomplete masks
        offset: Pagination offset
        limit: Number of items per page

    Returns:
        Tuple of (list of Image objects, total count)
    """
    base_query = session.query(Image.id).outerjoin(Mask).group_by(Image.id)

    if which == "segmentation":
        if done == 1:
            filtered_query = base_query.having(
                func.count(Mask.id) > 0,
                func.count(Mask.id) == func.sum(Mask.is_segmented),
            )
        else:
            filtered_query = base_query.having(
                (func.count(Mask.id) == 0)
                | (func.count(Mask.id) != func.sum(Mask.is_segmented))
            )
    else:  # annotation process
        # For annotation, first filter for images with completed segmentation
        segmented_images = base_query.having(
            func.count(Mask.id) > 0, func.count(Mask.id) == func.sum(Mask.is_segmented)
        ).subquery()

        # Then check annotation status on the segmented images
        base_query = session.query(Image.id).join(
            segmented_images, Image.id == segmented_images.c.id
        )
        base_query = base_query.outerjoin(Mask).group_by(Image.id)

        if done == 1:
            filtered_query = base_query.having(
                func.count(Mask.id) == func.sum(Mask.is_annotated)
            )
        else:
            filtered_query = base_query.having(
                func.count(Mask.id) != func.sum(Mask.is_annotated)
            )

    subquery = filtered_query.subquery()

    # Get paginated images
    images = (
        session.query(Image)
        .join(subquery, Image.id == subquery.c.id)
        .order_by(Image.filename)
        .offset(offset)
        .limit(limit)
        .all()
    )

    # Get total count
    total_count = session.query(func.count()).select_from(subquery).scalar()

    return images, total_count


def upload_image(session: Session, data: UploadImageRequest) -> ApiImage:
    """
    Upload a new image to the system.

    Args:
        session: Database session
        image_data: ApiImage object containing image data

    Returns:
        ApiImage object with updated information

    Raises:
        ValueError: If invalid file format or upload fails
    """
    image_data = data.base64_data
    if image_data == "" or not image_data.startswith("data:image/"):
        raise ValueError("Invalid image data")
    # Get the next image ID
    next_id = get_next_image_id(session)
    ext = image_data.split(";")[0].split("/")[1]  # Extract file extension
    # Generated by Copilot
    new_filename = f"{next_id:04d}.{ext}"
    upload_dir = "data/dataset/images"

    # Ensure directory exists
    os.makedirs(upload_dir, exist_ok=True)
    image_path = os.path.join(upload_dir, new_filename)

    try:
        # Save the file
        with open(image_path, "wb") as buffer:
            base64_image = image_data.split(",")[1]
            image_data_bytes = base64.b64decode(base64_image)
            buffer.write(image_data_bytes)
    except Exception as e:
        raise ValueError(f"Failed to save image: {str(e)}")

    # Add to the database
    db_image = Image(filename=new_filename, img_path=image_path)
    session.add(db_image)
    session.commit()
    return ApiImage(
        id=db_image.id, filename=new_filename, src=image_data, is_done=False
    )


def delete_image(session: Session, image_id: int) -> bool:
    """
    Delete an image and its associated files.

    Args:
        session: Database session
        image_id: ID of the image to delete

    Returns:
        bool: True if deletion was successful

    Raises:
        ValueError: If image not found
    """
    # Find the image in the database
    image = session.query(Image).filter_by(id=image_id).first()
    if not image:
        raise ValueError("Image not found")

    # Delete the image file
    image_path = image.img_path
    if os.path.exists(image_path):
        os.remove(image_path)

    # Delete associated masks
    mask_dir = os.path.join("data/dataset/masks", os.path.splitext(image.filename)[0])
    if os.path.exists(mask_dir):
        import shutil

        shutil.rmtree(mask_dir)

    # Remove from the database
    session.delete(image)
    session.commit()

    return True
