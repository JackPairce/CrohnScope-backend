"""
Mask service module for handling mask operations.

This module handles mask CRUD operations and related business logic.
"""

# Generated by Copilot
import os
import numpy as np
import cv2
from typing import List
from sqlalchemy.orm import Session
from API.db.models import Image, Mask, Cell, HealthStatusEnum
from API.services.image.patch_service import save_image_as_patches
from shared.types.image import ApiMask, MaskSaveRequest, RegionInfo, process_type
from shared.utils.converters import ImageToBase64, ToBase64

# from API.services.image.mask_tracker import record_mask_modification
from API.services.image import region_service


def get_masks(
    session: Session, image_id: int, withRegion: bool = False
) -> List[ApiMask]:
    """
    Get all masks for an image. For each mask:
    - If it's a .npy file, load it as a matrix where:
      0: background
      1: unhealthy cells
      2: healthy cells (if any regions were marked as healthy)
    - If it's an image file and no .npy exists, convert to .npy format

    Args:
        session: Database session
        image_id: ID of the image

    Returns:
        List[ApiMask]: List of masks with their data
    """
    masks = session.query(Mask).filter_by(image_id=image_id).all()
    if not masks:
        return []

    api_masks = []

    for mask in masks:
        npy_path = os.path.join(
            os.path.dirname(mask.mask_path),
            os.path.splitext(os.path.basename(mask.mask_path))[0] + ".npy",
        )
        # Check if npy file exists or we need to convert old image
        if not os.path.exists(npy_path):
            if os.path.exists(mask.mask_path):
                # Convert old image to npy format
                mask_array = region_service.decode_base64_image(
                    ToBase64(mask.mask_path)
                )
                binary_mask = (mask_array > 0).astype(np.uint8)
                np.save(npy_path, binary_mask)
                # Update path in database
                mask.mask_path = npy_path
                session.commit()
            else:
                continue  # Skip if neither file exists        # Load the mask from npy file
        mask_array = np.load(npy_path, allow_pickle=True)

        # Convert to base64 for API response - black background (0) and white foreground (255)
        _, buffer = cv2.imencode(".png", (mask_array > 0).astype(np.uint8) * 255)

        region_info = None
        if withRegion:
            # Get labeled regions info
            try:
                # Get connected regions and their health status
                _, labels = cv2.connectedComponents((mask_array > 0).astype(np.uint8))

                _, regions = region_service.get_region_stats(labels)
                region_info = [
                    RegionInfo(
                        id=r["id"],
                        area=r["area"],
                        boundingBox=r["boundingBox"],
                        centroid=r["centroid"],
                    )
                    for r in regions
                ]
            except Exception as e:
                print(f"Error getting region stats for mask {mask.id}: {e}")
                region_info = None

        api_masks.append(
            ApiMask(
                id=mask.id,
                image_id=mask.image_id,
                src=ImageToBase64(buffer),
                cell_id=mask.cell_id,
                is_segmented=not not (mask.is_segmented),
                regions=region_info,
            )
        )

    return api_masks


def save_mask_for_cell(
    session: Session, image_id: int, cell_id: int, mask_data: MaskSaveRequest
) -> bool:
    """Save a mask for a specific cell type.

    Args:
        session: Database session
        image_id: ID of the image
        cell_id: ID of the cell type
        mask_data: Mask data including base64 image and mask ID

    Returns:
        bool: True if successful, False otherwise


    Raises:
        ValueError: If image or cell not found
    """
    try:
        # Get the image and cell records
        image = session.query(Image).filter_by(id=image_id).first()
        cell = session.query(Cell).filter_by(id=cell_id).first()
        if not image or not cell:
            return False

        # Create masks directory if it doesn't exist
        mask_dir = os.path.join(
            "data/dataset/masks", os.path.splitext(image.filename)[0]
        )
        os.makedirs(mask_dir, exist_ok=True)

        # Define output path for the mask
        mask_path = os.path.join(mask_dir, f"{cell.name}.npy")

        # Convert to numpy array
        mask_array = np.array(mask_data.data)

        # Save as numpy file
        np.save(mask_path, mask_array)

        # Update or create the database record
        db_mask = session.query(Mask).filter_by(id=mask_data.id).first()
        if db_mask:
            db_mask.mask_path = mask_path
            db_mask.is_segmented = 0  # Reset done status
            db_mask.is_annotated = 0  # Reset annotation status
        else:
            db_mask = Mask(
                image_id=image_id,
                mask_path=mask_path,
                cell_id=cell_id,
                is_segmented=0,
                health_status=HealthStatusEnum.unhealthy,
            )
            session.add(db_mask)

        session.commit()
        return True
    except Exception as e:
        print(f"Error saving mask: {e}")
        session.rollback()
        return False


def save_masks(session: Session, image_id: int, masks: List[MaskSaveRequest]) -> bool:
    """
    Save multiple masks for an image.

    Args:
        session: Database session
        image_id: ID of the image the masks belong to
        masks: List of mask data

    Returns:
        bool: True if all saves were successful

    Raises:
        ValueError: If image not found
    """
    # Check image exists
    image = session.query(Image).filter_by(id=image_id).first()
    if not image:
        raise ValueError(f"Image ID {image_id} not found")

    # Save each mask
    for mask in masks:
        save_mask_for_cell(session, image_id, mask.cell_id, mask)

    session.commit()

    return True


def mark_mask_done(session: Session, mask_id: int, which: process_type) -> bool:
    """
    Mark a mask as done.

    Args:
        session: Database session
        mask_id: ID of the mask to mark as done

    Returns:
        bool: True if successful

    Raises:
        ValueError: If mask not found
    """
    db_mask = session.query(Mask).filter_by(id=mask_id).first()
    if not db_mask:
        raise ValueError("Mask not found")
    if which == "segmentation":
        db_mask.is_segmented = 1
    elif which == "annotation":
        db_mask.is_annotated = 1
    else:
        raise ValueError("Invalid which value")

    # save patches for the mask if all masks are done
    masks = session.query(Mask).filter_by(image_id=db_mask.image_id).all()
    if all(mask.is_segmented for mask in masks):
        image = session.query(Image).filter_by(id=db_mask.image_id).first()
        if image:
            save_image_as_patches(image)

    session.commit()
    return True


def alternate_masks(session: Session, image_id: int, mask1: str, mask2: str) -> bool:
    """
    Alternate (swap) two masks for an image.

    Args:
        session: Database session
        image_id: ID of the image
        mask1: First mask filename
        mask2: Second mask filename

    Returns:
        bool: True if successful

    Raises:
        ValueError: If masks or directory not found
    """
    # Find the mask directory
    mask_dir = os.path.join("data/dataset/masks", os.path.splitext(str(image_id))[0])
    if not os.path.exists(mask_dir):
        raise ValueError("Mask directory not found")

    # Alternate the mask names
    mask1_path = os.path.join(mask_dir, mask1)
    mask2_path = os.path.join(mask_dir, mask2)
    if not os.path.exists(mask1_path) or not os.path.exists(mask2_path):
        raise ValueError("One or both masks not found")

    temp_path = os.path.join(mask_dir, "temp_mask")
    os.rename(mask1_path, temp_path)
    os.rename(mask2_path, mask1_path)
    os.rename(temp_path, mask2_path)

    return True
