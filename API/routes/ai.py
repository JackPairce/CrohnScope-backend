from typing import List
from fastapi import APIRouter, BackgroundTasks
import numpy as np
from API.services.ai.auto_mask import (
    GENERATE_ALL_MASKS_STATE,
    generate_mask_for_image,
    generate_masks_for_new_images,
)
from API.db.session import SessionLocal
from API.db.models import Mask
from shared.types.ai import (
    MaskGenerationResponse,
)
from shared.types.image import ApiMask

router = APIRouter()

# Set this to the number of new images before retraining
RETRAINING_THRESHOLD = 10


# @router.get("/status", response_model=ModelStatusResponse)
# def get_model_status() -> ModelStatusResponse:
#     """
#     Get the current status of the AI model training process.

#     Returns:
#         ModelStatusResponse: Status information including training state, progress, metrics, and timing.
#     """
#     # Get detailed training status from the training module
#     status = get_training_status()

#     # Add additional contextual information
#     session = SessionLocal()
#     image_count = session.query(Image).count()
#     session.close()

#     # Calculate images needed for next training
#     if status["is_training"]:
#         next_training_in = 0
#     else:
#         images_since_last = image_count - status["image_count_at_last_training"]
#         mask_mods = status["mask_modifications_since_last_training"]
#         next_training_in_images = max(0, RETRAINING_THRESHOLD - images_since_last)
#         next_training_in_masks = max(0, RETRAINING_THRESHOLD - mask_mods)
#         next_training_in = min(next_training_in_images, next_training_in_masks)

#     # Determine status
#     if status["is_preprocessing"]:
#         current_status = "preprocessing"
#         progress = status["preprocessing_progress"]
#     elif status["is_training"]:
#         current_status = "training"
#         progress = status["progress"] * 100
#     else:
#         current_status = "idle"
#         progress = None

#     # Generated by Copilot
#     from shared.types.ai import TrainingDetails, TrainingTiming, NextTraining

#     result = ModelStatusResponse(
#         status=current_status,
#         details=TrainingDetails(
#             is_preprocessing=status["is_preprocessing"],
#             is_training=status["is_training"],
#             current_epoch=status["current_epoch"],
#             total_epochs=status["total_epochs"],
#             current_loss=round(status["current_loss"], 4),
#             best_loss=(
#                 round(status["best_loss"], 4)
#                 if status["best_loss"] != float("inf")
#                 else None
#             ),
#             progress_percent=(round(progress, 1) if progress is not None else None),
#             stable_epochs=status["stable_epochs"],
#         ),
#         timing=TrainingTiming(
#             started_at=status["start_time"],
#             elapsed=status.get("elapsed_formatted", "N/A"),
#             completed_at=(
#                 status["end_time"]
#                 if not status["is_training"] and status["end_time"]
#                 else None
#             ),
#         ),
#         next_training=NextTraining(
#             images_needed=next_training_in,
#             image_count=image_count,
#             last_training_at=status["image_count_at_last_training"],
#             mask_modifications_since_last=status[
#                 "mask_modifications_since_last_training"
#             ],
#         ),
#     )

#     return result


# @router.post("/train", response_model=TrainingResponse)
# def trigger_training(background_tasks: BackgroundTasks) -> TrainingResponse:
#     """
#     Manually trigger model training.

#     Returns:
#         TrainingResponse: Status message and whether training was started.
#     """
#     if start_training_if_needed():
#         # Generated by Copilot
#         return TrainingResponse(message="Training started", status="training")
#     else:
#         # Generated by Copilot
#         return TrainingResponse(
#             message="Training already in progress or no new data available",
#             status="unchanged",
#         )


@router.get("/generate-mask/{image_id}", response_model=List[ApiMask])
def generate_mask(image_id: int) -> List[ApiMask]:
    """
    Generate a mask for a specific image using the AI model.

    Args:
        image_id: ID of the image to generate the mask for

    Returns:
        MaskGenerationResponse: Status message indicating success or failure
    """
    session = SessionLocal()
    # get masks ids and cell types
    masks_ids = (
        session.query(Mask.id, Mask.cell_id).filter(Mask.image_id == image_id).all()
    )
    session.close()

    if not masks_ids:
        raise ValueError("No masks found for the specified image.")

    masks = generate_mask_for_image(image_id)
    return [
        ApiMask(
            id=mask_id.id,
            image_id=image_id,
            cell_id=mask_id.id,
            src=str(np.array(mask, dtype=np.uint8).tolist()),  # Convert to list
        )
        for (mask_id, mask) in zip(masks_ids, masks)
    ]


IS_GENERATE_ALL_MASKS = False


@router.post("/generate-masks", response_model=MaskGenerationResponse)
def generate_all_masks(background_tasks: BackgroundTasks) -> MaskGenerationResponse:
    """
    Generate masks for all images that don't have masks yet.
    This runs in the background as it may take some time.

    Returns:
        MaskGenerationResponse: Status message indicating task has started
    """
    # Generated by Copilot
    global IS_GENERATE_ALL_MASKS
    if IS_GENERATE_ALL_MASKS:
        return MaskGenerationResponse(
            message=f"Mask generation for all images is already in progress ({GENERATE_ALL_MASKS_STATE})",
            status="processing",
        )
    IS_GENERATE_ALL_MASKS = True
    # Run in background
    background_tasks.add_task(generate_masks_for_new_images)

    # Generated by Copilot
    return MaskGenerationResponse(
        message="Started generating masks for new images", status="processing"
    )


# Background task to check for training conditions on each request
# @router.get("/check-training-conditions", response_model=TrainingResponse)
# def check_conditions() -> TrainingResponse:
#     """Check if training should be triggered based on current conditions."""
#     start_training_if_needed()
#     return TrainingResponse(message="Training conditions checked", status="checked")


# @router.get("/training-process", response_model=TrainingProcessResponse)
# def get_training_process_status():
#     """
#     Get the current status of the training process.

#     Returns:
#         TrainingProcessResponse: Status information including process ID, start time, and current status
#     """
#     from shared.types.training import TrainingProcessResponse, TrainingStatusEnum

# Convert to proper response model
# return TrainingProcessResponse(**status_dict)
