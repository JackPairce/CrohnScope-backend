"""
Mask service module for handling mask operations.

This module handles mask CRUD operations and related business logic.
"""

# Generated by Copilot
import os
import numpy as np
import cv2
import json
import base64
from typing import List, Optional
from sqlalchemy.orm import Session
from app.db.models import Image, Mask, Cell, HealthStatusEnum
from app.types.image import ApiMask, SaveMaskResponse, RegionInfo
from utils.converters import ToBase64, base64_to_file
from app.services.image.mask_tracker import record_mask_modification
from app.services.image import region_service


def get_masks(session: Session, image_id: int) -> List[ApiMask]:
    """
    Get all masks for an image. For each mask:
    - If it's a .npy file, load it as a matrix where:
      0: background
      1: unhealthy cells
      2: healthy cells (if any regions were marked as healthy)
    - If it's an image file and no .npy exists, convert to .npy format

    Args:
        session: Database session
        image_id: ID of the image

    Returns:
        List[ApiMask]: List of masks with their data
    """
    masks = session.query(Mask).filter_by(image_id=image_id).all()
    if not masks:
        return []

    api_masks = []

    for mask in masks:
        npy_path = os.path.join(
            os.path.dirname(mask.mask_path),
            os.path.splitext(os.path.basename(mask.mask_path))[0] + ".npy",
        )
        # Check if npy file exists or we need to convert old image
        if not os.path.exists(npy_path):
            if os.path.exists(mask.mask_path):
                # Convert old image to npy format
                mask_array = region_service.decode_base64_image(
                    ToBase64(mask.mask_path)
                )
                binary_mask = (mask_array > 0).astype(np.uint8)
                np.save(npy_path, binary_mask)
                # Update path in database
                mask.mask_path = npy_path
                session.commit()
            else:
                continue  # Skip if neither file exists        # Load the mask from npy file
        mask_array = np.load(npy_path, allow_pickle=True)

        # Get connected regions and their health status
        _, labels = cv2.connectedComponents((mask_array > 0).astype(np.uint8))

        # Use the mask file's values directly:
        # 0: background
        # 1: unhealthy regions
        # 2: healthy regions
        # No need to use region_statuses anymore since health is stored in the mask values

        # Convert to base64 for API response - black background (0) and white foreground (255)
        _, buffer = cv2.imencode(".png", (mask_array > 0).astype(np.uint8) * 255)
        mask_data = f"data:image/png;base64,{base64.b64encode(buffer).decode('utf-8')}"

        # Get labeled regions info
        try:
            _, regions = region_service.get_region_stats(labels)
            region_info = [
                RegionInfo(
                    id=r["id"],
                    area=r["area"],
                    boundingBox=r["boundingBox"],
                    centroid=r["centroid"],
                )
                for r in regions
            ]
        except Exception as e:
            print(f"Error getting region stats for mask {mask.id}: {e}")
            region_info = None

        api_masks.append(
            ApiMask(
                id=mask.id,
                image_id=mask.image_id,
                mask_path=mask.mask_path,
                src=mask_data,
                cell_id=mask.cell_id,
                is_mask_done=not not (mask.is_mask_done),
                labeledMask=None,  # No need for colored visualization
                regions=region_info,
            )
        )

    return api_masks


def save_mask_for_cell(
    session: Session, image_id: int, cell_id: int, mask_data: SaveMaskResponse
) -> bool:
    """Save a mask for a specific cell type.

    Args:
        session: Database session
        image_id: ID of the image
        cell_id: ID of the cell type
        mask_data: Mask data including base64 image and mask ID

    Returns:
        bool: True if successful, False otherwise


    Raises:
        ValueError: If image or cell not found
    """
    try:
        # Get the image and cell records
        image = session.query(Image).filter_by(id=image_id).first()
        cell = session.query(Cell).filter_by(id=cell_id).first()
        if not image or not cell:
            return False

        # Create masks directory if it doesn't exist
        mask_dir = os.path.join(
            "data/dataset/masks", os.path.splitext(image.filename)[0]
        )
        os.makedirs(mask_dir, exist_ok=True)

        # Define output path for the mask
        mask_path = os.path.join(mask_dir, f"{cell.name}.npy")

        # Convert base64 to numpy array
        mask_array = region_service.decode_base64_image(mask_data.src)

        # Convert to three-state mask:
        # 0: background (black)
        # 1: unhealthy regions (red)
        # 2: healthy regions (green)
        three_state_mask = np.zeros(mask_array.shape[:2], dtype=np.uint8)

        # BGR to RGB conversion for OpenCV
        is_red = (
            (mask_array[:, :, 2] > 128)
            & (mask_array[:, :, 1] < 64)
            & (mask_array[:, :, 0] < 64)
        )  # Red pixels
        is_green = (
            (mask_array[:, :, 1] > 128)
            & (mask_array[:, :, 2] < 64)
            & (mask_array[:, :, 0] < 64)
        )  # Green pixels

        three_state_mask[is_red] = 1  # Unhealthy regions
        three_state_mask[is_green] = 2  # Healthy regions

        # Save as numpy file
        np.save(mask_path, three_state_mask)

        # Update or create the database record
        db_mask = session.query(Mask).filter_by(id=mask_data.id).first()
        if db_mask:
            db_mask.mask_path = mask_path
            db_mask.is_mask_done = 0  # Reset done status

            # Calculate health status based on region proportions
            total_annotated = np.sum(three_state_mask > 0)
            if total_annotated > 0:
                healthy_ratio = np.sum(three_state_mask == 2) / total_annotated
                db_mask.health_status = (
                    HealthStatusEnum.healthy
                    if healthy_ratio > 0.5
                    else HealthStatusEnum.unhealthy
                )
            else:
                db_mask.health_status = HealthStatusEnum.unhealthy

            record_mask_modification(image_id, cell_id)
        else:
            db_mask = Mask(
                image_id=image_id,
                mask_path=mask_path,
                cell_id=cell_id,
                is_mask_done=0,
                health_status=HealthStatusEnum.unhealthy,
            )
            session.add(db_mask)

        session.commit()
        return True
    except Exception as e:
        print(f"Error saving mask: {e}")
        session.rollback()
        return False


def save_masks(session: Session, image_id: int, masks: List[SaveMaskResponse]) -> bool:
    """
    Save multiple masks for an image.

    Args:
        session: Database session
        image_id: ID of the image the masks belong to
        masks: List of mask data

    Returns:
        bool: True if all saves were successful

    Raises:
        ValueError: If image not found
    """
    # Check image exists
    image = session.query(Image).filter_by(id=image_id).first()
    if not image:
        raise ValueError(f"Image ID {image_id} not found")

    # Save each mask
    for mask in masks:
        save_mask_for_cell(session, image_id, mask.cell_id, mask)

    return True


def mark_mask_done(session: Session, mask_id: int) -> bool:
    """
    Mark a mask as done.

    Args:
        session: Database session
        mask_id: ID of the mask to mark as done

    Returns:
        bool: True if successful

    Raises:
        ValueError: If mask not found
    """
    db_mask = session.query(Mask).filter_by(id=mask_id).first()
    if not db_mask:
        raise ValueError("Mask not found")

    db_mask.is_mask_done = 1
    session.commit()
    return True


def alternate_masks(session: Session, image_id: int, mask1: str, mask2: str) -> bool:
    """
    Alternate (swap) two masks for an image.

    Args:
        session: Database session
        image_id: ID of the image
        mask1: First mask filename
        mask2: Second mask filename

    Returns:
        bool: True if successful

    Raises:
        ValueError: If masks or directory not found
    """
    # Find the mask directory
    mask_dir = os.path.join("data/dataset/masks", os.path.splitext(str(image_id))[0])
    if not os.path.exists(mask_dir):
        raise ValueError("Mask directory not found")

    # Alternate the mask names
    mask1_path = os.path.join(mask_dir, mask1)
    mask2_path = os.path.join(mask_dir, mask2)
    if not os.path.exists(mask1_path) or not os.path.exists(mask2_path):
        raise ValueError("One or both masks not found")

    temp_path = os.path.join(mask_dir, "temp_mask")
    os.rename(mask1_path, temp_path)
    os.rename(mask2_path, mask1_path)
    os.rename(temp_path, mask2_path)

    return True
