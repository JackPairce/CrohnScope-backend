"""
Region labeling utilities for mask processing.

This module provides functionality to analyze connected regions in masks
and generate labeled versions where each connected component has a unique ID.
"""

# Generated by Copilot
import cv2
import base64
import numpy as np
from typing import List, Tuple


def decode_base64_image(base64_string: str) -> np.ndarray:
    """Convert base64 image string to numpy array."""
    try:
        # Remove the data URL prefix if present
        if "," in base64_string:
            base64_string = base64_string.split(",")[1]

        # Decode base64 to bytes
        image_bytes = base64.b64decode(base64_string)

        # Convert bytes to numpy array
        image_array = np.frombuffer(image_bytes, dtype=np.uint8)

        # Decode image array as color
        image = cv2.imdecode(image_array, cv2.IMREAD_COLOR)

        return image
    except Exception as e:
        raise ValueError(f"Error decoding base64 image: {str(e)}")


def encode_labeled_mask(mask: np.ndarray) -> str:
    """Convert labeled mask to base64 string."""
    try:
        # Convert to an RGB image where:
        # 0 = black (background)
        # 1 = red (unhealthy)
        # 2 = green (healthy)
        rgb_mask = np.zeros((*mask.shape, 3), dtype=np.uint8)
        rgb_mask[mask == 1] = [255, 0, 0]  # Red for unhealthy
        rgb_mask[mask == 2] = [0, 255, 0]  # Green for healthy

        # Encode the image
        success, buffer = cv2.imencode(".png", rgb_mask)
        if not success:
            raise ValueError("Failed to encode image")

        # Convert to base64
        base64_string = base64.b64encode(buffer).decode("utf-8")
        return f"data:image/png;base64,{base64_string}"
    except Exception as e:
        raise ValueError(f"Error encoding labeled mask: {str(e)}")


def label_connected_components(mask_data: str) -> Tuple[str, List[dict]]:
    """
    Label connected components in a binary mask.

    Args:
        mask_data: Base64 encoded mask image

    Returns:
        Tuple of:
        - Base64 encoded labeled mask image where each region has a unique color
        - List of region statistics (area, centroid, etc.)
    """
    try:
        # Decode the mask
        mask = decode_base64_image(mask_data)

        # Ensure the mask is binary
        _, binary_mask = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)

        # Find connected components
        num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(
            binary_mask, connectivity=8
        )

        # Generate region statistics
        regions = []
        # Skip label 0 as it's the background
        for i in range(1, num_labels):
            x, y, w, h, area = stats[i]
            cx, cy = centroids[i]
            regions.append(
                {
                    "id": i,
                    "area": int(area),
                    "boundingBox": {
                        "x": int(x),
                        "y": int(y),
                        "width": int(w),
                        "height": int(h),
                    },
                    "centroid": {"x": int(cx), "y": int(cy)},
                }
            )

        # Convert labeled mask to colored visualization
        colored_mask = encode_labeled_mask(labels)

        return colored_mask, regions

    except Exception as e:
        raise ValueError(f"Error processing mask: {str(e)}")


def get_region_stats(labels: np.ndarray) -> Tuple[np.ndarray, List[dict]]:
    """
    Get statistics for labeled regions in a mask.

    Args:
        labels: Matrix where each region has a unique ID (from cv2.connectedComponents)

    Returns:
        Tuple of:
        - Original labels matrix
        - List of region statistics (area, centroid, bounding box)
    """
    num_labels = int(labels.max())
    regions = []
    # Skip label 0 as it's the background
    for i in range(1, num_labels + 1):
        # Create a binary mask for this region
        region_mask = (labels == i).astype(np.uint8)
        region_mask_uint8 = np.ascontiguousarray(region_mask, dtype=np.uint8)

        # Get region statistics using cv2.connectedComponentsWithStats
        _, _, stats, centroids = cv2.connectedComponentsWithStats(
            region_mask_uint8, connectivity=8
        )

        # Get stats for the region (index 1 since there's only one region in the mask)
        x, y, w, h, area = stats[1]
        cx, cy = centroids[1]

        regions.append(
            {
                "id": i,
                "area": int(area),
                "boundingBox": {
                    "x": int(x),
                    "y": int(y),
                    "width": int(w),
                    "height": int(h),
                },
                "centroid": {"x": int(cx), "y": int(cy)},
            }
        )

    return labels, regions
