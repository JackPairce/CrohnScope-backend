import os
from typing import List
import cv2
from numpy import ndarray, array
from torch import device, load, cuda, from_numpy

from API.db.models import Cell
from API.db.session import SessionLocal
from API.services.image.patch_service import (
    reconstruct_image_from_patches,
    split_image_into_patches,
)
from shared.models.Unet.models import UNet
from shared.types.image import MaskArray


def predict_mask(image: ndarray) -> List[MaskArray]:
    """
    Predict the mask for a given image using the UNet model.

    Args:
        image (ndarray): The input image to predict the mask for.
        cell_name (str): The name of the cell type to predict the mask for.

    Returns:
        ndarray: The predicted mask for the image.
    """
    session = SessionLocal()
    num_cells = session.query(Cell).count()
    session.close()
    if num_cells == 0:
        raise ValueError(
            "No cell types found in the database. Please add cell types before predicting masks."
        )

    # Load the UNet model
    model = UNet(in_channels=3, num_classes=num_cells)

    # Load the pre-trained weights
    model_path = os.path.abspath("data/models/best_unet_weights.pth")
    trained_weights = load(model_path, map_location=device("cpu"))["model_state_dict"]
    # remove "module." prefix if it exists
    trained_weights = {k.replace("module.", ""): v for k, v in trained_weights.items()}
    model.load_state_dict(trained_weights)

    # split image into patches
    patches, positions, _, _ = split_image_into_patches(image)

    # to tensor
    patches = from_numpy(array(patches)).float().to("cpu")
    patches = patches.permute(0, 3, 1, 2)  # Change to (N, C, H, W)

    # Make the prediction
    masks = model(patches)
    masks = masks.detach().cpu().numpy()  # Convert to numpy array
    masks = masks.transpose(1, 0, 2, 3)  # Change to (C, N, H, W)

    if masks.shape[0] != num_cells:
        raise ValueError(
            f"Number of predicted masks ({masks.shape[0]}) does not match number of cell types ({num_cells}).",
            f"Got masks shape: {masks.shape}, Cell types count: {num_cells}",
        )

    # reconstruct the mask from patches
    list_masks: List[MaskArray] = []
    for i in range(masks.shape[0]):
        # fill all enclosed areas with 1
        # Generated by Copilot
        mask: MaskArray = (
            (
                cv2.morphologyEx(
                    (
                        reconstruct_image_from_patches(
                            masks[i], positions, (*image.shape[:2],), patches.shape[2]
                        )
                        < 0.5
                    ).astype("uint8"),
                    cv2.MORPH_CLOSE,
                    kernel=cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5)),
                )
            )
            .astype("uint8")
            .tolist()
        )
        list_masks.append(mask)

    return list_masks
